!function(){THREE.LWOLoader=function(e){this.manager=void 0!==e?e:THREE.DefaultLoadingManager,this.materials=[],this.geometry=new THREE.BufferGeometry},THREE.LWOLoader.prototype={constructor:THREE.LWO2Loader,load:function(e,r,t,a){var n=this,o=new THREE.FileLoader(n.manager);o.setResponseType("arraybuffer"),o.load(e,function(e){r(n.parse(e))},t,a)},parse:function(e){function r(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}function t(e){return String.fromCharCode(255&e,e>>8&255,e>>16&255,e>>24&255)}var a=new DataView(e);const n=4,o=1,s=2,c=4,i=4,d=12,g=2,l=4,u=4,f=1179603533,v=0,b=4,E=1280790322,w=1280790338,y=8;if(a.getInt32(v)!==f)return void console.error("THREE.LWO2Loader.parse: Cannot find header.");var h=a.getInt32(b);if(h+8!==a.byteLength&&console.warn("THREE.LWO2Loader.parse: Discrepency between size in header ("+h+" bytes) and actual size ("+a.byteLength+" bytes)."),a.getInt32(y)!==w&&a.getInt32(y)!==E){var k=(new TextDecoder).decode(new Uint8Array(e,y,4));return void console.error("THREE.LWO2Loader.parse: Invalid magic ID ("+k+") in LWO header.")}const I=1347310675,T=1397900883,L=1347374163,p=1129469523,m=1346586707,A=1398100550,R=8,H=6;for(var F=new THREE.BufferGeometry,D=null,U=12;U<a.byteLength;)if(0===a.getUint8(U))U++;else{var C=a.getInt32(U),h=a.getInt32(U+4);switch(U+=R,C){case I:if(h%12!==0)return void console.error("THREE.LWO2Loader.parse: F12 does not evenly divide into chunk size ("+h+"). Possible corruption.");for(var O=h/4,W=new Float32Array(O),x=0;x<O;x++)W[x]=a.getFloat32(U+4*x);this.geometry.addAttribute("position",new THREE.BufferAttribute(W,3)),console.dir(this.geometry),console.dir(W);break;case T:var B=(new TextDecoder).decode(new Uint8Array(e,U,h)),z=B.split("\0").filter(function(e){return""!=e});console.log(z);break;case L:for(var G=0,M=0;M<h;){var S=a.getInt16(U+M),P=a.getInt16(U+M+2+2*S);this.geometry.addGroup({start:G,count:S,materialIndex:P}),G+=3*(S-2),M+=4+2*S}M=0;for(var V=0,j=new Int16Array(G);M<h;){for(var S=a.getInt16(U+M),P=a.getInt16(U+M+2+2*S),q=new Int16Array(S),x=0;x<=S;x++)q[x]=a.getInt16(U+M+2*x);for(var x=0;x<S-2;x++)j[V++]=q[0],j[V++]=q[x+1],j[V++]=q[x+2];M+=4+2*S}this.geometry.setIndex(new THREE.BufferAttribute(j,1));break;case A:const J=1129270354,K=1179402567,N=1280658761,Q=1145652806,X=1397769539,Y=1380271692,Z=1414676814,_=1447843149,ee=1447315782,re=1448300611,te=1447449164,ae=1448366670,ne=1196183379,oe=1380338772,se=1380535623,ce=1380535876,ie=1162102597,de=1397571918,ge=1129596248,le=1146373464,ue=1398031704,fe=1381254488,ve=1414808920,be=1280591192,Ee=1112819032,we=1413893191,ye=1414744410,he=1413698642,ke=1413890380,Ie=1414939980,Te=1413696594,Le=1413696594,pe=1413565776,me=1414090055,Ae=1413565520,Re=1415008848,He=1413562707,Fe=1414484035;for(var M=0;0!==a.getUint8(U+M);)M++;for(var De=(new TextDecoder).decode(new Uint8Array(e,U,M)),Ue=new THREE.Material({name:De}),Ce=null;M<h;){var Oe=U+M;if(0===a.getUint8(Oe))M++;else{var We=a.getInt32(Oe),xe=a.getInt32(Oe+4);switch(M+=H,We){case J:for(var Be=[],x=0;x<4;x++)Be.push(a.getUint8(Oe+x)/255);var ze=(new THREE.Color).fromArray(Be);console.dir(ze);break;case K:break;case N:var Ge=a.getInt16(Oe)/255;break;case Q:var Me=a.getInt16(Oe)/255;break;case X:var Se=a.getInt16(Oe)/255;break;case Y:var Pe=a.getInt16(Oe)/255;break;case Z:var Ve=a.getInt16(Oe)/255;break;case _:var Ge=a.getFloat32(Oe);break;case ee:var Me=a.getFloat32(Oe);break;case re:var Se=a.getFloat32(Oe);break;case te:var Pe=a.getFloat32(Oe);break;case ae:var Ve=a.getFloat32(Oe);break;case ne:break;case oe:break;case se:break;case ce:break;case ie:break;case de:break;default:console.warn("Found unrecognised subchunk type "+(new TextDecoder).decode(new Uint8Array(e,Oe-H,4))+" at "+Oe)}M+=xe}}console.log("Surface name: "+De);break;default:console.warn("Found unrecognised chunk type "+(new TextDecoder).decode(new Uint8Array(e,U-8,4))+" at "+U)}U+=h}}}}();